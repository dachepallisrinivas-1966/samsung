JDK Download
----------------
https://www.oracle.com/in/java/technologies/javase/javase8u211-later-archive-downloads.html

Eclipse Download
---------------------
https://www.eclipse.org/downloads/packages/
Choose →	Eclipse IDE for Enterprise Java and Web Developers
Choose →	Windows x86_64




Java
-----
What is Java?
+	It is strictly but partially an object oriented programming language.

Who developed Java?
+	James Gosling at sun microsystems

Features of Java
+	platform independent
+	secured
+	robust
+	object oriented

+	portable
+	compiled-interpreted
+	multi-threaded
+	architectural neutral
+	disributed



JDK, JRE and JVM?
+	JDK = JRE + Development tools (javac, java, javaw, javap, javadoc, jdb, javah, jar, appletviewer)
+	JRE = JVM + libraries (rt.jar etc.,) + other files

Is JDK platform independent?
+	No
Is JRE platform independent?
+	No
Is JVM platform independent?
+	No



platform means o/s.

sample.java	(source code)	→	javac (compiler)	→	sample.class	(bytecode)
byte code is not in 0's and 1's. it is understood by jvm
byte code should be given to jvm. jvm will convert the bytecode into NATIVE MACHINE CODE (0's and 1's) that is
understood by the current o/s in which the program is executed.

bytecode is the platform indendent.


secured?
+	no explicit pointers
+	programs run inside jvm, not in o/s directly.

robust?
+	means strong, vigour and healthy.
+	exception handling
+	strong type checking mechanism


CODING STANDARDS
+	proper naming conventions
+	proper indentation


'C' vs Java?
+	const keyword is not there
+	include is not there
+	struct, union are not there
+	typedef is not there
+	pointers are not there
+	no goto statement

C++ vs Java?
+	no operator overloading
+	no friend function
+	no friend classes
+	no scope resolution operator
+	no reference variables
+	no multiple inheritance


								Java Tokens
								-----------

+	smallest part of the program is called as Token.
	a) identifiers
	b) operators
	c) keywords
	d) literals
	e) comments	

						
1)	identifiers
	-	name given to variables, classes, methods etc.,

	a)	Pascal Notation		:	first letter of every word in upper case and the rest in lower case
						eg: class names, interface names etc.,

						eg: ArrayIndexOutOfBoundsException, ArrayList, TreeMap etc.,

	b)	Camel Notation		:	first word is in lowercase, from the second word onwards Pascal Notation
						eg: variable names, method names etc.,

						eg: firstNumber, indexOf(), lastIndexOf() etc.,
			
	c)	Uppercase Notation	:	constants

	d)	Lowercase Notation	:	package names
						eg: java.io, java.awt, java.util, java.lang etc.,


2) operators
	-	arithmetic	:	+	-	*	/	%
	-	relational	:	>	<	==	>=	<=	!=
	-	logical		:	&&	||	!
	-	assignment	:	=	+=	-=	*=	/=	%=
	-	bit-wise 	:	&	|	~	>>	<<	^
	-	conditional operator :	(condition) ? true-statement : false-statement
	-	increment/decrement :	++	--
	-	special operators :
		;	[]	
		+	string concatenation
		"instance of"	operator


3) keywords (reserved words)
	-	if, switch, for, int, float, long


4) literals
	-	any fixed value that does not change during the program execution.

	numeric literals
	-	integer literals
		-	decimal		-	base 10		-	0 - 9		-	no prefix	
		-	binary		-	base 2		-	0,1		-	0b prefix
		-	octal		-	base 8		-	0-7		-	0  prefix
		-	hexa-decimal	-	base 16		-	0-9,A-F		-	0x prefix


		int a = 101;
		int b = 0b101;
		int c = 0101;
		int d = 0x123ABCF;


	-	floating-point literals
		-	2.56
	
	non-numeric literals
	-	character literals
		-	single alphabet, single digit, single special symbol enclosed within single quotes
			eg:	'A'	'7'	'?'
	-	string literals
		-	group of characters enclosed within double quotes.
			eg:	"srinivas"	"49-53-20/25"	"9247175823"	"A"	"" (empty string literal)
	-	boolean literals
			true, false


5) comments
	a)	//   				end-of-line comment
	b)	/* 	..	*/		block comment
	c)	/** 	..	*/		documentation comment



	a) identifiers
	b) operators
	c) keywords
	d) literals
	e) comments	


what are the tokens in the following statement?

	double 		area 		= 		PI		*		radius		*		radius		;
		
	keyword		identifier	operator	constant	operator	identifier	operator	identifier	operator



what is the difference between a literal and constant?

	it is also known as symbollic constant.
	it is a name given to literal.
	whose value can never be changed in the program execution.
	constants can be defined using "final" keyword.


	double PI = 3.14;		// declaring a variable whose name is PI.
	final double PI = 3.14;		// declaring a constant whose name is PI

	final int MAX_MARKS = 100;
	final int PASS_MARKS = 35;

	PI, MAX_MARKS, PASS_MARKS are called constants
	3.14, 100, 35 are called literal.


what are the various data types?

+	primitive
		byte, short, int, long
		float, double
		char, boolean

+	non-primitive (user-defined)
		class, interface, enum, annotation



package:
	it is a collection of related classes, interfaces and sub packages.
	internally it is represented as a folder in O/S.


	reverse of the domain name.	

	www.samsung.com	→	com.samsung.ui, com.samsung.model, com.samsung.service, com.samsung.controller



System.out.println("Hello world");
	
	System		►	class available in java.lang package
	out		►	a static object of java.io.PrintStream class
	println()	►	a method in java.io.PrintStream class


String[] args?
	called as command-line arguments.
	this is another way of taking inputs.


print all the command line arguments.

print the sum of two numbers passed as command line arguments.


Can main method be overloaded?
---------------------------------
YES



Wrapper classes		(java.lang)
------------------------------------


	wrapper class			static method
	--------------------------------------------------------------------
	Integer				parseInt(string-form-int)
	Double				parseDouble(string-form-double)




	int a = Integer.parseInt("123");
	System.out.println(a);			//	123


	double b = Double.parseDouble("25.789");
	System.out.println(b);			//	25.789



Can we have two main methods in a java program?
(or)
Can main method be overloaded?

	YES.
	

method overloading:
+	if two or more methods in a class having the same name but with different parameter list, then it is said to be 
	overloading.




						control structures	
						(control statements)
					--------------------------------------------

+	if, switch				(decision making)
+	for, while, do..while, enhanced for	(looping)
+	break, continue				(jump)
+	labelled break, labelled continue


what is the difference between if and switch?
+	"if" is a bi-directional decision making statement.
	> , <, ==, >=, <= , !=
	int, long, float, double, byte, short, char, boolean

+	"switch" is a multi-directional decision making statement.
	only ==	(equality) comparisions
	illegal data types	:	float, double, boolean
	legal data types	:	char, byte, short, int, enum, String


for, while, do..while	-	statements are executed as long as the condition is true.


how to choose between for and while?
	for loop is used to iterate set of statements for a finite number of times.
	where as while loop is used to iterate set of statements for an indefinite number of times. 


	factorial program	►	for
	reversing a number	►	while


what is do..while loop?
+	to execute a loop at least once irrespective of the condition.


what is the result of a condition?
+	true or false


what is the difference between break and continue?
+	whenever a break statement is encountered within any loop, the control immediately comes out of the loop 
	without executing remaining iterations.



1) accept a number. reverse it. print it.
	eg: input : 749
	ouput : 947

2) accept a number. print the sum of the digits it.
	eg: input : 749
	output : 20	(=9+4+7)

3) accept a number. print whether it is prime number or not.

4) accept a number. print whether it is palindrome or not.
	eg: input : 121
	    output : palindrome

5) accept a number. print whether it is armstrong or not.

	eg: input : 153
	output : 3^3 + 5^3 + 1^3 = 153	

6) fibonacci series


Array
+	It is a linear collection of homogeneous data items stored under single name.
+	It is a static data structure means we cannot change the size of the array.
+	In java, array is an object.
+	Every array has a special field, "length" that return number of elements in that array.

types of array:
+	single dimension
+	multi dimension
+	jagged array


java.util.Scanner:
+	used to accept the data into variables during runtime

+	nextInt()
+	nextDouble()
+	nextLine()
+	next()


enhanced for loop:
+	syntax:
		for(datatype  var : array/collection) {
			statement(s);
		}

what is the difference between for and enhanced for loop:
+	the loop variable in for loop is always int.
	the loop variable in enhanced for loop is always same as the array type.
+	enhanced for loop can be used only in forward direction (start element to stop element).


initializing an array:
+	int[] arr = { 10, 20, 30 };


note:
+	every row in a double dimensional array is treated as a single dimension array internally by java.


     darr[3][3]
1	2	3	→	darr[0]		
4	5	6	→	darr[1]
7	8	9	→	darr[2]


Jagged Array:
+	each row contain different number of columns.


eg:

	jarr

1	2	3			==>	jarr[0]
4	5				==>	jarr[1]
6					==>	jarr[2]
7	8	9	10		==>	jarr[3]




java.util.Arrays:

+	this class offer many utility methods that can work on arrays.

static methods of Arrays class:
--------------------------------
+	toString(array)
+	equals(array-1, array-2)
+	sort(array)
+	binarySearch(array-1, key)
	+	the array must be in sorted order to perform binarySearch operation.


+	deepToString(darray)
+	deepEquals(darray-1, darray-2)



functions (methods):

+	It is a sub program designed to perform a specific task that can be used repeatedly.


+	function definition
		returnType   functionName(datatype  arg-1, datatype  arg-2, ...) {
			statment(s);
		}

+	function call
		[var = ] functionName(arg-1, arg-2, ...);


actual parameters	:	parameters specified in the function call statement
formal parameters	:	parameters specified in the function definition


function to return the sum of the digits.


function overloading (method overloading):
+	if two or more functions (methods) having the same name but with different parameter list then it is said to be overloading.
 


Can I pass array as an argument to function?
+	YES

Can I return an array from a function?
+	YES


function return minimum and maximum in an array using functions.



							varargs
						(variable arguments)

"..." (three dots) symbol is known as "ellipsis".
it represent the function can take any number of values that are comma-seperated.


Note:
+	the varargs parameter must be the last formal parameter in the function definition.



								String class
								-------------
							     (java.lang package)

java.lang 	►	default package
			means it is imported automatically for every program.

			eg: String, System, Integer, Float, Double, Long, Boolean etc.,

java.lang.String:
-------------------
+	it is a pre-defined class
+	it is immutable (not modifiable)


declaring String object:
------------------------
1) String str;
2) String str = "java";
	         0123
3) String str = new String();
4) String str = new String("hello");

methods:
--------
a) length()
b) charAt(index)
	str.charAt(0)		→	j
c) indexOf(String)
	str.indexOf("a");	→	1	(first occurance)
d) lastIndexOf(String)
	str.lastIndexOf("a")	→	3	(last occurance)
e) substring(start_index_inclusive  [, end_index_exclusive])
	str.substring(2,4)	→	va
	str.substring(2)		→	va
f) startsWith()	→	str.startsWith("ja")	→	true
g) endsWith()	→	str.endsWith("va")	→	true
h) contains()	→	str.contains("a")	→	true
i) toUpperCase()	
j) toLowerCase()
k) concat()	→	to combine two string
l) replace(old_char, new_char)
m) trim()	→	remove both leading and trailing spaces.
n) equals()	→	compare two strings considering case
o) equalsIgnoreCase()
p) compareTo()	→	to compare two strings	→	return 0 if both are equal, +ve value if string1 is big, -ve value if string2 is big
q) isEmpty()
r) toCharArray()
s) split(regex)

What is the difference between == and equals() ?

what is the difference between equals() and compareTo() ?


StringBuilder and StringBuffer:
--------------------------------
+	these are peer classes of java.lang.String
+	both are mutable (modifiable)

methods:
a) length()
b) capacity()
c) append()
d) insert()
e) replace()
f) delete()
g) reverse()

what is the difference?
+	StringBuilder is NOT THREAD-SAFE where as StringBuffer is THREAD-SAFE.



							OOPS
					(Object Oriented Programming System)

+	It is a programming paradigm.
	+	monolithic programming
	+	procedural programming
	+	structured programming
	+	object oriented programming
		-	programs are written that simulate real world objects.
	+	functional programming

class	:	It is a user defined datatype that represent an entity in terms of properties and behaviour.
		It is a reusable software component.
		properties are also known as "data members" or "fields".
		behaviours are represented as "methods" (method is a funcrtion that defined inside a class)
		No memory is allocated when we define a class.

		classes are created for different purposes.
		classes are also known as "model" or "pojo"	(POJO stands for Plain Old Java Object)

object	:	It is a variable whose data type is class.
		It is the runtime instance of a class.
		memory is allocated only when an object is created.


advantages of OOP:
+	code reusability
+	security


features of OOP:
+	encapsulation		: 
+	data hiding		: keeping data safe 
+	abstraction		: behaviour hiding


take any real world example and explain encapsulation, data hiding and abstraction?


+	inheritance
+	polymorphism
+	message passing
+	persistence




access specifiers (access modifiers):
+	private
	+	members can be accessed only within the class in which they are defined
+	public
	+	members can be accessed from any class.
+	default
	+	members can be accessed from any class in the same package
+	protected
	+	members can be accessed from sub classes also.


setters (mutators) and getters (accessors):
+	setter is a public method of a class through which other programs can change the value of associated data member.
+	getter is a public method of a class through which other programs can retrieve the value of associated data member



"this" reference:
+	"this" means implied object.
+	it holds the reference of current object that is invoking a constructor or method.




how do you implement data hiding?
+	making data members as private.

how do you implement encapsulation?
+	providing setters and getters.

data members are stored independently for each object.
methods are stored only once in the memory and thay are accessed by all objects of the class.



static:
+	static means "sharable"

static can be used in 4 ways
+	static data member
	-	these are also known as "common data members"
	-	it is stored only once but can be accessed by all objects of the class.
	-	it is used to store common data across all objects.

+	static method
	-	these are used to manage static data members.
	-	it will not allow non-static members
	-	static method can be called directly with the class name. we don't need to have any object to call it.
	-	we cannot use "this" keyword in a static method.

+	static block
	-	block is a group of statements enclosed within curly braces.
	-	static block is a block that is defined with "static" keyword.
	-	it is the first code block that is executed in the program.
	-	it is executed automatically 
		-	whenever the class is accessed for the first time.
			-	by creating an object of that class
			-	whenever a static method is called
			-	whenever a static data member is accessed

	can we have multiple static blocks?
	-	WE CAN.


+	static class	
	-	it can be used only on inner class


Can I overload static methods?
+	YES

class Test {
	public static void show(int x) {
		System.out.println(x);
	}

	public static void show(double x) {
		System.out.println(x);	
	}
}

class TestApp {
	public static void main(String[] args) {
		Test.show(100);
		Test.show(5.6);
	}
}




assignment:
+	palindrome program using String class.



constructors:
+	It is a special method and is executed automatically whenever an object is created.
+	It should have the same name as that of class.
+	It can have parameters
+	But it cannot return any value, and should not have return type as "void".
+	A class can have many constructors. This is called "constructor overloading".

+	It is used to initialize data members.
								

types of constructors:
+	default constructor	(no-parameter constructor)
+	parameter constructor
+	copy constructor

note:
+	when a class do not have any constructor, java provide one default constructor.
+	but if the class has atleast one constructor, java do not provide any constructor.


assignment:
-----------
create a class Product with the following data members - id, name, price.
whenever we create objects, supply only name and price.
id should be autogenerated. (first product id - 1001, second product - 1002, .... etc.,)

	
inheritance:
+	creating a new class (sub class) from an existing class (super class)
+	sub class can use all the features of super class as well as any extra features that are added to it.
+	using "extends" keyword we can create a sub class.
+	it represent an "is-A" relationship	(tightly coupled)
+	it is mainly for code reusability.


types of inheritance:
----------------------
+	simple (single)
+	hierarchical
+	multi-level

+	multiple inheritance is not supported in java. to acheive this, we have to use interfaces.


super:
------
+	super is used to call super class constructor from sub class constructor.
		super(arg-1, arg-2, ...)
	if used, super() call must be the first statement in the code block.

+	super is used to access super class data members or super class methods from sub class.
		super.dataMember
		super.method(arg-1, arg-2, ...)

+	if super() is to be used, it must be the first statement in the code block.
+	this() and super() cannot be used at a time.	(mutually exclusive)



what is the difference between method overloading and method overriding?

method overloading:
--------------------
when two methods have the same name but with different parameter list.

method overriding:
-------------------
when a sub class contain a method that has same signature as that of another method in it's super class then the sub class method is said to be
overriding.

method signature	=	 method name + parameter list



it is a best practice to use "@Override" annotation on overrided methods.
it is optional.
But if used, when overriding is not done properly, compiler will give an error.





class Test {
	public int add(int a, int b) {
		return a+b;
	}
	public int mul(int a, int b) {
		return a*b;
	}
	public int add(int a, int b, int c) {			// overloading
		return a+b+c;
	}
	
}


class subTest extends Test {
	public int add(int a, int b) {				// overriding	
		return a+b+100;
	}
	public int mul(int a, int b, int c) {			// overloading
		return a*b*c;
	}
}


class TestApp {
	public static void main(String[] args) {
		Test obj = new Test();
		System.out.println(obj.add(5,6));		// 11
		SubTest obj2 = new SubTest();
		System.out.println(obj2.add(6,7));		// 113
		System.out.println(obj2.add(1,2,3));		// 6

	}
}
		

java.lang.Object	class
------------------------------
+	it is universal super class (cosmic class)
+	every class in java, whether it is pre-defined or user-defined, they are inherited from java.lang.Object class.

methods:
1) public String toString()
2) public boolean equals(Object o)
3) public int hashCode()
4) public Object clone()
5) protected void finalize() throws Throwable 


					person(name, age)
						↑
						↑
	Employee	(salary)	←----------------→	Student		(fee)
	    ↑
	Manager		(bonus)


constructor phenomenon:
-----------------------

+	when an object is created, the constructor of that class is called.

+	when an object of sub class is created, super class constructor is called first and 
    	then the sub class constructor is called. This hold true for any levels of inheritance.

	when a sub class object is created with

	i) default constructor		then the super class default constructor is called.
	ii) parameter constructor	then the super class default constructor is called.
	iii) copy constructor		then the super class default constructor is called.



Abstract Polymorphism	(Abstraction)
---------------------------------------------------------
+	abstraction is "disclosing only required details and hiding the background implementation".
+	abstract means "incomplete or unclear". It is an idea but we don't know how to implement.
+	abstraction means "behaviour hiding".


abstract class:
--------------------
	It is a class which should not have objects created.

	In this scenario, we never need to create an object for Person.
        so, Person class can be declared as an abstract.

	to make a class as an abstract, it must be defined with an "abstract" keyword.
	we cannot instantiate (create an object) an abstract class.


abstract method:
----------------------
	It is a method which do not have any implementation (i.e., definition)

	1) an abstract method must be written only inside an abstract class.
	2) but an abstract class need not contain any abstract method.
	3) all sub classes of abstract class, must implement (override) all abstract methods. 
       	4) if not, the sub class must also be marked as "abstract".

abstract class A {
    abstract void show();
}

class B extends A {
    @Override
    protected void show() {               
        System.out.println("B");
    }
}

class Test {
    public static void main(String [] args) {
        B obj = new B();
        obj.show();
    }
}

error:
    cannot reduce the visibility of the inherited method.


private	► protected ► default ► public



polymorphism:
	poly means many
	morph means forms

	exhibiting different behaviours for a same method call.

	

	man	►	move()	►	walk
	fish	►	move()	►	swim
	bird	►	move()	►	fly
	snake	►	move()	►	crawl

	move()	is known as polymorphic method.	


	polymorphism
	+	compile-time polymorphism	(early binding)
		eg: method overloading

	+	run-time polymorphism		(late binding)
		eg: method overriding

note:
-----
	we can store object of a sub class in a super class reference variable.



Type Casting:
-------------
	Converting one datatype to another.
	It is only work on primitive data types.

	2 types.

	a) Broadening	(promotion)		implicit
	b) Narrowing	(demotion)		explicit


	primitive types:
	-------------------
	a) broadening:
	    -----------------
	int x = 45;
	double d = x;		(implicit)	- broadening

	double d2 = 67;		// OK
	int y = '@';		// OK

	char -> int -> double

	a) narrowing: (explicit):
	------------------------------
	int x = 45.1;		// error
	int x = (int)45.1;	// OK

	char ch = (char)156;	// OK


Referencing:  (UpCasting and DownCasting):
------------------------------------------
       					     Employee
			                        |
            	-----------------------------------------------------------------
	        |					                        |
              Manager				                	ContractEmployee
	        |
       Managing Director


eg:
	Employee emp1 = new Employee();	
	Employee emp2 = new Manager();		
	Employee emp3 = new ContractEmployee();	
	Employee emp4 = new ManagingDirector();
	Manager m2 = new ManagingDirector();	


	Manager m3 = new ContractEmployee();			// Not Possible	
	ContractEmployee ce = new Employee();			// Not Possible



	user-defined data types:
	-----------------------------------------
	ContractEmployee ce2 = emp3;				// Not Possible		

	ContractEmployee ce2 = (ContractEmployee)emp3	
	

	
final keyword:
------------------
1) final class : it cannot be inherited.
2) final method : it cannot be overridden.
3) final variable : value of which cannot be modified. (constant)

what is the opposite keyword of final?

	???


interface:
----------
+	It is a user-defined datatype but contain only public abstract methods and public static final variables.	(upto JDK 1.7)
+	It is mainly used to achieve multiple inheritance.
+	We can acheive 100% abstraction.

+	we cannot create object for an interface.
+	create a sub class (using implements keyword) and override all the abstract methods then create object for the sub class and use it.


class		►	extends		►	sub class
interface	►	implements	►	sub class
interface	►	extends		►	sub interface

class		►	NOT POSSIBLE 	►	sub interface

eg-1:
------

interface   B {

}

interface   C {

}
class	A	implements	B, C {

}


eg-2:
-----
class	X {

}

interface  Y {

}


class    Z   extends  X   implements   Y {

}

eg-3:
-----
interface A {

}
interface B {

}

interface C   extends  A, B {

}


what is the difference between abstract class and interface?
???


	

 								Built-In Packages
						                ------------------
                                        			(Java SE Libraries)

java.lang			(default package - because it is imported for every program)
	Wrapper classes - Integer, Double, Float, Long, Boolean
	Object          
	System
	Math
	String
	StringBuffer
	StringBuilder
	Exception
	Throwable interface
	Runnable interface
	Thread
	
java.util
    Scanner
    Date        (deprecated)
    Calendar    (deprecated)
    Collection API


java.io
    BufferedReader	


1) java.lang.System class:
   -------------------------------

	class variables			              	object
	-------------------				---------
	public static java.io.InputStream		in
	public static java.io.PrintStream		out
	public static java.io.PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)		terminates the program then and there. int could be either a 0 or 1.
    


2) java.lang.Math
-------------------
	public static fields:
	------------------------
		E, PI
    	
	public static methods
	----------------------------
		double pow()
		double sin(angle in radians)
            	Math.sin(30)    =>  ???
            	Math.sin(Math.toRadians(30))    =>  0.5

        	double cos(angle in radians)
		double sqrt()

		ceil() : return next integer
            	Math.ceil(11.2) => 12
		floor() : return previous integer
            	Math.floor(11.9) => 11
		round() 
            	Math.round(11.2) =>  11
            	Math.round(11.9) =>  12

		abs()
		toRadians()
		toDegrees()



Boxing:
    converting primitive variable into a corresponding wrapper object

    int x = 89;
    Integer iobj = x;   // auto-boxing

unBoxing:
    converting wrapper object back into corresponding primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; 	// auto-unboxing


static import: (JDK 1.5)
------------------------
    java.lang.Math class provide static methods.
        sqrt()
        abs()
        pow()

    int a, b;
    double hypotenuse = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));

    (or)
    import static java.lang.Math.sqrt;
    import static java.lang.Math.pow;

    double hypotenuse = sqrt(pow(a,2) + pow(b,2));


    import java.util.Scanner;       // recommended
    import java.util.*;             // bad coding practice
	

	

								Exception Handling
								------------------

Exception is an object that represents a situation where the application is terminated.
Every Exception is a pre-defined class in Java.



   		java.lang.Throwable (i)
                        |
                        |
            ---------------------------------
            |                               |
            java.lang.Error         java.lang.Exception
                                            |
                                            |
                                    java.lang.RuntimeException



Exception classes that are derived from java.lang.RuntimeException class - UNCHECKED
unchecked exceptions are not informed by the compiler.

All other are  								 - CHECKED


try, catch, finally
throw, throws

	
	1) try : contain the code where the exception can be generated.
    	2) catch : contain statements that are to be executed when the specified exception occurred in the associated try block
        3) finally : contain the code to be executed whether an exception occurred or not.  
            the most relevant exception classes mention first.
            least relevant exception mention next.

    a try block must follow an immediate catch block (or) a finally block.

            try {				try {
                ..					...
            } finally {				} catch(ExceptionClassName excep) {
                ...					...
            }					}

    a try can have many catch blocks.
    a try block can have another try block within it.

    
note:
----- 
+	we are not supposed to handle UnChecked Exceptions		(Coding Standards)
        we have to avoid these exceptions using a technique called "Defensive programming".


+	if you do not handle checked exceptions, the compiler will give errors.
+	checked exceptions must be handled, they cannot be avoided.



User Defined Exceptions:
------------------------
1. create a class which should be derived from java.lang.Exception (checked) or java.lang.RuntimeException (unchecked)
2. write a constructor that takes a String parameter.
3. call the super class constructor by passing this String to it.


4. in the app,
	enclose the problamatic code inside a try block.
	raise the user defined exception using "throw" keyword.
	handle the user defined exception in the corresponding catch block.

throw keyword:
--------------
+	to raise an exception

throws keyword:
----------------
+	delegating the exception handling responsibility to the caller of the method.


JDK 7 Enhancements:
---------------------------------
a) multi-catch exception

    try {
	    statement(s)
    } catch (Exception-1   | Exception-2  |  Exception-3    obj) {
	    statement(s)
    }


b) try-with-resources

    try (declare closable resources here....){
                    ........................
    } catch(....){

    }

    the closable resource will be close automatically.

    a Resource has to implement java.lang.Closable or java.lang.AutoClosable interface
    to be recognized as closable.






 								Generics
							        --------
These are called as ADT	(abstract data types)

when there is a logic which is indepedent of datatypes, then we can use ADT. 
eg: Sorting on int's, float's, double's or char's are same.

generics are implemented using angular brackes. < >. The imaginary datatype is represented as T. 
eg: <T>.
if we have two imaginary datatypes then <T1, T2>

generics do not support primitive types.
T can be Book, Car, ComplexNumber, Employee etc.,
but not with int, char, float, double.
if it is inevitable, we may use Wrapper classes.

1) generic methods

	public void sort(T[] arr) {
		// logic goes here ...
	}


2) generic classes

class  Test<T> {
	private:
		T   data;
	}
}

								Collection API   (java.util)
								----------------------------
								(Collection Framework)
API	►	Application Programming Interface

It is a collection of interfaces, abstract classes.
Java provided implementation classes also for Collection API.


Collections contain following 3 elements:
a) declarations
b) implementations
c) algorithims

Advantages of Collections:
+	Reduces programming effort 
+	Increases performance 
+	Provides interoperability 



							<< Collection API Diagram >>

List interface
+	allow duplicate items
+	index-based operations are possible
+	nulls are allowed


	+	ArrayList class
		-	is best when traversal is done more
		-	insertions and deletions are less
		-	internally use an expandable array
		-	it is not thread-safe

			add(), remove(), set(), size(), get(), iterator()
			clear(), isEmpty()

		what is the default capacity of an array list?
			10

		when we are trying to add 11 the element, the capacity is automatically increased.
			newCapacity = oldCapacity + (oldCapacity >> 1)
	
		capacity is increased by 50%.
	

	+	LinkedList class
		-	is best when insertions and deletions are frequently done.
		-	internally use a double-linked list.

			descendingIterator()
			
	
	+	Vector		(legacy class)



what is difference between iterator and list iterator?
???

how do you compare two arraylists whether they are equal or not?
???

what is the difference between arraylist and vector?
+	vector is a legacy class
+	it is a thread-safe (synchronized)
+	the default capacity for vector is 10.
+	the capacity is increased by 100%.


write a demo program on Vector?
???

write a demo program on PriorityQueue?
???




Set interface
+	do not allow duplicates
+	no index based operations are possible


	+ HashSet class		:	order of retrieval is uncertain.
	+ LinkedHashSet		:	insertion order
	+ TreeSet		:	sorted order


Map interface
+	used to store key-value pair of data.
+	key cannot be duplicated
+	value can be duplicated
+	only one key can be null.
+	value can have any number of nulls.
+	key + value together known as "Entry".


	+ HashMap		: order of retrieval is uncertain.
	+ LinkedHashMap		: insertion order
	+ TreeMap		: sorted order of key


	put(k,v), get(k), remove(key), containsKey(key), containsValue(value)
	keySet(), values(), entrySet()


java.util.Collections class:
-------------------------------
	a) sort(arrayList)
	b) binarySearch()
	c) fill()


Program-to-Interfaces:  (Coding Standard)
----------------------------------------------

	List<Integer> list = new ArrayList<>();

java.lang.Comparable interface:
---------------------------------
	Employee class should be inherited from Comparable interface.
	
	public int compareTo(Employee o) {
		// logic goes here ..
	}


java.util.Comparator interface:	
--------------------------------
	Without disturbing the Employee class, other programmers can create their own comparators.


	public int compare(Employee o1, Employee o2) {
		// logic goes here ..
	}


what is the difference between Comparable and Comparator?
---------------------------------------------------------

		Comparable									Comparator
		----------									----------
1) Comparable provides a single sorting sequence. In other words, 		The Comparator provides multiple sorting sequences. 
   we can sort the collection on the basis of a single element 			In other words, we can sort the collection on the basis
   such as id, name, and price.	 						of multiple elements such as id, name, and price etc.

2) Comparable affects the original class, i.e., the actual class 		Comparator doesn't affect the original class, i.e., the 
   is modified.	  								actual class is not modified.

3) Comparable provides compareTo() method to sort elements.			Comparator provides compare() method to sort elements.

4) Comparable is present in java.lang package.					A Comparator is present in the java.util package.

5) We can sort the list elements of Comparable type by 				We can sort the list elements of Comparator type by 
   Collections.sort(List) method.						Collections.sort(List, Comparator) method.



what is the contract between equals() and hashCode() ?

	when two objects are equal as per equals() method, the hash codes must be same.
	but the vice versa is not true.

	when ever you override equals() method, make sure that hashCode() is also override.




							IOStream API (java.io)
							----------------------
stream : flow of data.

iostreams are used to store the data permanantly (in the form of files)

two types:
1) text stream	(character stream)
	-	to store any kind of information


	Reader
		FileReader
		BufferedReader
	Writer
		FileWriter
		PrintWriter

2) binary stream (byte stream)
	-	to store objects, audio, video, image

	InputStream
		FileInputStream
		ObjectInputStream
	OutputStream
		FileOutputStream
		ObjectOutputStream

serialization	:	storing (writing) object into a file
			the class should implement java.io.Serializable interface.
			Serializable interface is called as a null interface or marker interface (no methods to override)

			writeObject()

de-serialization :	reading object from a file.
			
			readObject()

transient	:	field that is marked with this modifier, it won't be participated in Serialization process.




								Object Cloning
								--------------

The clone() method of java.lang.Object class creates a shallow copy of the object.

Here, the shallow copy means it creates a new object and copy all the fields and methods associated with the object.

The class should be inherited from Cloneable interface.
we have to override clone() method.


							final, finally and finalize()?
							------------------------------
+	finalize() is the method of Object class. 
+	This method is automatically called just before an object is garbage collected. 
+	finalize() method overrides to dispose system resources, perform clean-up activities and minimize memory leaks.


								Multi Threading
								----------------
what is a thread?
+	it is a light weight process.
+	we can have multiple threads in a program using which we can perform multiple tasks parallelly.

how many ways?
+	by extending java.lang.Thread class
+	by implementing java.lang.Runnable interface

constructors:
+	public Thread()
+	public Thread(Runnable)


why two ways?
+	if you want to create a thread on a sub class, we cannot use extends again.
+	here we have to use implements Runnable.


class 		A 	
{

}


class		B	extends		A   implements Runnable {


}




what is a thread life cycle?
[diagram]

life cycle methods?
+	start()
+	stop()
+	run()		:	it contain statements related to the task
				it is executed automatically when we call start()

other methods:
wait()
notify()
notifyAll()
sleep(milliseconds)	

suspend()	:	outdated
yield()		:	outdated
resume()	:	outdated

currentThread()
setName()
getName()
getPriority()
setPriority()
getId()
isAlive()
setDaemon(boolean)


Thread priorities:
---------------------
It is an integer between 1 to 10.

1	MIN_PRIORITY
5	NORM_PRIORITY		(default priority)
10	MAX_PRIORITY


What is Daemon thread?
+	Daemon thread is abruptly terminated when no other threads are running.
+	It cannot run on its own.

setDaemon(true);


synchronization?
+	it is the capability to control the access of multiple threads to any shared resource.

+	synchronized method
+	synchronized block

producer-consumer pattern:
---------------------------



								AWT
							(Abstract Window Toolkit)

to develop windows based application (GUI)
+	using AWT components
+	using Swing API  (JFC - Java Foundation Class Library)


								Applet

+	An applet is a Java program that can be embedded into a web page. 
+	It runs inside the web browser and works at client side. 
+	An applet is embedded in an HTML page using the APPLET or OBJECT tag and hosted on a web server.




							Initialization Blocks
							---------------------

Order of execution of Initialization blocks and constructor in Java:
---------------------------------------------------------------------

+	Static initialization blocks will run whenever the class is loaded first time in JVM
+	Initialization blocks run in the same order in which they appear in the program.
+	Instance Initialization blocks are executed whenever the class is initialized and before constructors are invoked. They are typically placed above the constructors within braces.


class Test {
  
    Test (int x)
    {
        System.out.println("ONE argument constructor");
    }
  
    Test ()
    {
        System.out.println("No  argument constructor");
    }
  
    static
    {
        System.out.println("1st static init");
    }
  
    {
        System.out.println("1st instance init");
    }
  
    {
        System.out.println("2nd instance init");
    }
  
    static
    {
        System.out.println("2nd static init");
    }
  
    public static void main(String[] args)
    {
        new Test ();
        new Test (8);
    }
}


[4] 10-feb-2022

								Assertions in Java
								------------------

+	An assertion allows testing the correctness of any assumptions that have been made in the program. 
+	An assertion is achieved using the assert statement in Java. 
+	While executing assertion, it is believed to be true. If it fails, JVM throws an error named "AssertionError". 
+	It is mainly used for testing purposes during development. 

+	The assert statement is used with a Boolean expression and can be written in two different ways.

+	First way: 

	+	assert expression;

+	Second way:  

	+	assert expression1 : expression2;


Why use Assertions?

+	Wherever a programmer wants to see if his/her assumptions are wrong or not. 
+	To make sure that an unreachable-looking code is actually unreachable.

	eg:
	---
	class Scrap {
    		public static void main(String args[])
    		{
        		int a = 2;
        		for (;;) {
 
            		if (a == 2)
            		{
                		break;
                		// it will never execute, so
                		// same error will be there.
                		System.out.println("I want to get printed");
            		}
        	}
    	}

+	To make sure that assumptions written in comments are right.


Assertion Vs Normal Exception Handling?

+	Assertions are mainly used to check logically impossible situations. 
+	For example, they can be used to check the state a code expects before it starts running or 
	the state after it finishes running. 
+	Unlike normal exception/error handling, assertions are generally disabled at run-time. 

Where to use Assertions?  

+	Arguments to private methods. 
+	Private arguments are provided by the developer’s code only and 
	the developer may want to check his/her assumptions about arguments.
+	Conditional cases.
+	Conditions at the beginning of any method.

Where not to use Assertions?

+	Assertions should not be used to replace error messages
+	Assertions should not be used to check arguments in the public methods as 
	they may be provided by the user. Error handling should be used to handle errors provided by users.
+	Assertions should not be used on command line arguments.


legal access modifiers:
--------------------------
data members	:	default, private, protected, public, static, abstract, final
methods		:	default, private, protected, public, static, abstract, final
class		:	default, public, final, abstract, static

Nested Classes:
--------------- 
1. Static member class
2. Non-Static member class
3. Method-local inner class
4. Anonymous inner class



enum:	(JDK 1.5)
----------------------------
+	"enum" stands for "enumeration".
+	"enum" in java is a user data type that contain fixed set of constants.
+	it represent possible values of a property.

+	It can be used for day of the week (SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY and SATURDAY) , 
+	directions (NORTH, SOUTH, EAST and WEST)
+	Season (WINTER, SPRING, SUMMER, FALL)
+	gender (MALE, FEMALE)   

+	The java enum constants are static and final implicitly. 
+	Java Enums can be thought of as classes that have fixed set of constants.

+	enum ensures type safety.

assume we do not have enums?

what could be the data type of gender? it depends on programmer.
assume we want 1 to represent MALE and 0 to represent FEMALE. we can make gender as int. but the problem is the user can pass any integer, 
which is not type-safe.
assume we want "M" to represent MALE and "F" to represent FEMALE.. we can make gender as char. but the problem is the user 
can pass any character, which is not again type-safe.
assume we want "MALE" to represent MALE and "FEMALE" to represent FEMALE. we can make gender as string. but the user can pass any string.

in case we use an "enum", which contain pre-defined set of values associated to it.

eg:
	public	enum	Gender {
		MALE, FEMALE
	}




							JDBC 
							----

interface/abstract class				implementation classes
				
	abstract methods					implementation of abstract methods

JDBC API	:	collection of interfaces, abstract class	(Java People - Sun Microsystems)

	Oracle	→	Oracle JDBC Driver	→	implementation classes of JDBC API (java programs) 
	MySQL	→	MySQL JDBC Driver	→	implementation classes of JDBC API
	MS SQL Server →	MS SQL Server JDBC Driver →	implementation classes of JDBC API


5 Steps:
--------
●	Register the driver class
●	Creating connection
●	Creating statement
●	Executing queries
●	Closing connection


java.sql package: (part of JDBC API):
-------------------------------------
DriverManager class
+	getConnection(connectionStringUrl, username, password)
Connection interface
+	Statement createStatement()
+	PreparedStatement prepareStatement(sql)
Statement interface
+	int executeUpdate(sql)	: for INSERT / UPDATE / DELETE
+	executeQuery(sql)		: for SELECT
PreparedStatement interface
+	int executeUpdate()	: for INSERT / UPDATE / DELETE
+	executeQuery()		: for SELECT
CallableStatement interface
+	used to call stored procedure / stored functions  (PL/SQL)
ResultSet interface
+	used to retrieve data
+	next()



2 ways
+	download the jdbc driver from the database vendor website 
	copy the jdbc driver into "lib" folder
	add the jdbc driver to the build path
	then start writing program

+	use Maven project
	specify the required dependency entries in the configuration file (pom.xml)
	then start writing program

what is Maven?
+	It is a build tool
+	jar / war file (java archive file / web archive file) - deployment file

+	Maven maintain all libraries in it's Maven Central Repository
	(mvnrepository.com)


what is the difference between Statement and PreparedStatement?

		Statement									PreparedStatement
----------------------------------------------------------------------------------------------------------------------------------------------
1) It is used when SQL query is to be executed only once.			It is used when SQL query is to be executed multiple times.

2) You can not pass parameters at runtime.					You can pass parameters at runtime. (parameterized query)

3) Performance is very low.							Performance is better because it uses pre-compiled queries.

4) we can execute multiple sql commands using a single				we can execute only one sql command using a single 
   Statement object.								PreparedStatement object


Rowset interface:
-------------------
A RowSet is an object that encapsulates a set of rows from either java Database Connectivity (JDBC) result sets, with a 
standard set of properties and an event notification mechanism.

5 implementation classes:
--------------------------
+	CachedRowSet
+	FilteredRowSet

+	WebRowSet
+	JDBCRowSet
+	JoinRowSet


11-feb-2022

project - 1:	Library Management System
		-------------------------
Console Based Application
Java SE + Oracle + Maven
Multi Layered Architecture
+	presentation layer (UI Layer)
	+	is the layer through which the user is interacted with the application
+	business layer	   (Service Layer)
	+	to implement validations, computations, to call data access layer's methods
+	data access layer  (DAO Layer)
	+	to talk to the database, all database operations

design patterns:
+	DAO (Data Access Object) design pattern	
+	Program-to-interfaces
+	Single ton design pattern
	+ we have only one object can be created for a class.



 create table books
  2  (bcode number(4) primary key,
  3  title varchar(50) not null,
  4  price number(10,2) not null,
  5  category varchar(50) not null
  6  );



UI	↔	Service		↔	DAO	↔	Database



project-2:
----------
EmployeeManagementApp
	empId, empName, mobile, salary




							Java EE Frameworks
							------------------
Framework:
	It is a platform that contain libraries, API, design patterns, standardized environment to run the programs.

1) struts
2) jsf
3) hibernate
4) spring

							ORM     (Object Relational Mapping)
							-----------------------------------

    It is a framework or library that enables the automation of database operations, executions and implementations.


Data Representation                         OOP                             RDBMS   
....................................................................................................
Entity Def                                  class                           Table
Entity                                      object                          Row/Tuple
Properties                                  field                           column/attribute
Behaviours                                  method                          ---


It is a Paradigm Mismatch.


Has A Relationship (Aggregation)
 Composition
    an entity possess another entity        class Address {                 Employees
    An Employee composes of an Address          String street;               empid,name,salary,street,city
                                                String city;
                                            }

                                            class Employee {
                                                Long empId;
                                                String name;
                                                Double salary;
                                                Address address;
                                            }

                                            

 Association
    OneToOne                                class BankAccount {             BankAccount
                                                String accNum;                 accNum,ifsc,bankName
                                                String ifsc;
                                                String bankName;
                                                Employee holder;
                                            }

                                            class Employee{                 Employees
                                                Long empId;                     empid,name,basic,accnum
                                                String name;
                                                Dobule basic;
                                                BankAccount salAccount;
                                            }

    OneToMany                               class Department {              Depts
    ManyToOne                                   Long deptId;                   deptId,title
                                                String title;
                                                Set<Employee> emps;
                                            }

                                            class Employee {                Employees
                                                Long empId;                     empid,name,basic,deptid
                                                String name;
                                                Double basic;
                                                Department dept;
                                            }

    ManyToMany                              class Employee {                Employees
                                                Long empId;                     empid,name,basic
                                                String name;
                                                Double basic;
                                                Set<Project> projects;
                                            }     

                                            class Project {                 Projects
                                                Long projectId;                 prjId,title
                                                String projectTitle;
                                                Set<Employee> team;
                                            }
                                                                            Prj_Emps
                                                                                prjid,empid



                                            class Employee {                Employees
                                                Long empId;                     empid,name,basic
                                                String name;
                                                Double basic;
                                                @OneToMany
                                                Set<TeamMembership> projects;
                                            }     

                                            class Project {                 Projects
                                                Long projectId;                 prjId,title
                                                String projectTitle;
                                                @OneToMany
                                                Set<TeamMembership> team;
                                            }
                                            
                                            class TeamMembership {          Memeberships
                                                Long membershipId;              msid,empId,prId,role
                                                @ManyToOne
                                                Employee member;
                                                @ManyToOne
                                                Project project;
                                                String role;
                                            }


Is A Relationships (Realization)            class Employee {                
                                                Long empId;                   
                                                String name;
                                                Double basic;
                                            }

                                            class Manager extends Employee{
                                                Double allowance;
                                            }

                                            class ContractEmployee extends Employee {
                                                Integer duration;
                                            }

												Inheritance Strategies
                                                       Single Table       AllEmployees
                                                                             empid,name,basic,allowance,duration,emp_type (discriminator column)

                                                       Join Table           Emps    empid(PK),name,basic
                                                                            Mgrs    empid(PK FK),allowence
                                                                            cemps   empid(PK FK),duration
                                                                            
                                                       Table Per Class      Emps    empid(PK),name,basic
                                                                            Mgrs    empid(PK),name,basic,allow
                                                                            cemps   empid(PK),name,basic,duration


Proposal	→	Specifications		→	Implementation
(ORM)			(JPA & JTA)			(Hibernate)


	
JPA - Java Persistence API + (JTA - Java Transaction API)
-----------------------------------------------------------

    JPA and JTA are JavaEE specifications to provide the ORM for java applications.

    JPA / JTA implementations / JPA or JTA Providers
        1. Hibernate
        2. TopLink
	3. EclipseLink
        4. ibatis
	5. mybatis ...etc

    1. Entity Mapping

            @Entity                 class level     configs that a class is an entity
            @Embeddable             class level     configs that a class is a part of an entity

            @Table(name="")         class level     map the entity class with a table

            @Inheritence            class level     config the Is A type 
                                                    Inheritance Strategies ►	(Single table/join table/table per class)
           
	    @DiscriminatorColumn    class level	    eg: emp_type
            @DiscriminatorValue     class level

            @Embeded                Field level     config that a field is a embedable object (composition)

            @Id                     Field level     config a field as primary key
            @EmbededId              Field level     config a field as a composite key

            @GeneratedValue         Field level     used along with @Id
						    generation strategies
                                                        AUTO            the best strategy is choosen by hibernate
                                                        IDENTITY        SQL Server/MySQL PK as identity col
                                                        SEQUENCE        oracle 12c or higher sequence
							TABLE		hibernate_sequences table

            @Column                 Field level     is an optional annotation on each field
                                                    configs column name,nullable, unique ..etc
                                                    if a field is not marked with @column annotation, then
                                                    that field is mapped to a colmun having the smae name as 
                                                    that of the field.

            @Transient              Field level     config that a field need not be persisted in the db table.

            @OneToOne               Field level
            @OneToMany              Field level
            @ManyToOne              Field level
            @ManyToMany             Field level

                    mappedBy                        configs the name of the field of 
                                                    the entity on the oppsite side of the relation
                    fetchStrategy                  LAZY | EAGER
                    cascade                         ALL | PERSIST | MERGE | DELETE | NONE | REFERESH | ORPHAN

            @JoinColumn             Field level     config a name to the foreign key col
            @JoinTable              Field level     configs a thrid talbe for relatiosn incase of ManyToMany


Session methods:
1) save()
2) update()
3) delete()
4) get()
5) saveOrUpdate()
6) load()


what is the difference between get() and load()?
???


what is dialect?
???


5 Heros of hibernate:
1) ConnectionProvider
2) SessionFactory
3) Session
4) TransactionFactory
5) Transaction


6) TypedQuery


orm mapping can be done in two ways.
1) using .hbm.xml files	(eg: job.hbm.xml)	
2) using annotations





HQL	(Hibernate Query Language)
	HQL is all about using entity class and thier properties
	We don't use table names, column names while querying data unlike in SQL.


hibernate.cfg.xml
	session factory settings
		database name
		connection string url
		user name
		password
		jdbc driver information

		hibernate environment information

	hbm2ddl.auto	→	update / validate / create / create-drop


mapping information
1) using xml
	entityClassName.hbm.xml
	you have to register mapping information in hibernate.cfg.xml

2) using property files		(external configuration)

3) using annotations		(recommended)



			JPA									Hibernate
-------------------------------------------------------------------------------------------------------------------------------
1) JPA is described in javax.persistence package.			Hibernate is described in org.hibernate package.

2) It describes the handling of relational data 			Hibernate is an Object-Relational Mapping (ORM) tool that 
   in Java applications.                                   		is used to save the Java objects in the relational database system.                                    	

3) It is not an implementation. It is only a Java specification.	Hibernate is an implementation of JPA. Hence, the common standard 
									which is given by JPA is followed by Hibernate.

4) It is a standard API that permits to perform database operations.	It is used in mapping Java data types with SQL data types and 
									database tables.

5) As an object-oriented query language, it uses Java Persistence 	As an object-oriented query language, it uses Hibernate Query Language 
   Query Language (JPQL) to execute database operations.		(HQL) to execute database operations.

6) To interconnect with the entity manager factory for the 		To create Session instances, it uses SessionFactory interface.
   persistence unit, it uses EntityManagerFactory interface. Thus, 
   it gives an entity manager.


7) To make, read, and remove actions for instances of mapped 		To make, read, and remove actions for instances of mapped entity 
   entity classes, it uses EntityManager interface. 			classes, it uses Session interface. It acts as a runtime 
   This interface interconnects with the persistence condition.		interface between a Java application and Hibernate.


								Criteria API
								------------
what is the difference between using HQL and Criteria API?
???


								Caching
								-------

Caching is a facility provided by ORM frameworks which help users to get fast running web application, while help framework itself 
to reduce number of queries made to database in a single transaction. Hibernate achieves the second goal by implementing first level cache.

Its easy to understand the first level cache if we understand the fact that it is associated with Session object. As we know 
session object is created on demand from session factory and it is lost, once the session is closed. Similarly, 
first level cache associated with session object is available only till session object is live. 


Important facts:
+	First level cache is associated with “session” object and other session objects in application can not see it.

+	First level cache is enabled by default and you can not disable it.

+	When we query an entity first time, it is retrieved from database and stored in first level cache associated with hibernate session.

+	If we query same object again with same session object, it will be loaded from cache and no sql query will be executed.

+	The loaded entity can be removed from session using evict() method. The next loading of this entity will again make a database call if it has been removed using evict() method.

+	The whole session cache can be removed using clear() method. It will remove all the entities stored in cache.







								Spring Framework
								----------------

+	The Spring Framework provides a comprehensive programming and configuration model for modern 
	Java-based enterprise applications.

+	A key element of Spring is infrastructural support at the application level: Spring focuses on the "plumbing" of 
	enterprise applications so that teams can focus on application-level business logic, without unnecessary ties to 
	specific deployment environments.


What is the Spring Container?
+	The Spring container is also known as IoC (Inversion of Control) container. 
+	The Spring container is responsible for instantiating, configuring, and assembling the Spring beans. 
+	The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. 
+	The configuration metadata is represented in XML, Java annotations, or Java code with annotations


The responsibilities of IOC container are:
+	Instantiating the bean
+	Wiring the beans together
+	Configuring the beans
+	Managing the bean’s entire life-cycle

The org.springframework.beans and org.springframework.context packages are the basis for Spring Framework’s IoC container. 
Spring framework provides two distinct types of containers.
+	BeanFactory container
+	ApplicationContext container

+	BeanFactory is the root interface of Spring IOC container. 
+	ApplicationContext interace is the child interface of BeanFactory interface that provides Spring AOP features, i18n etc.

+	One main difference between BeanFactory and ApplicationContext is that ...
	+	BeanFactory only instantiates bean when we call getBean() method 
	+	while ApplicationContext instantiates singleton bean when the container is started, It doesn't wait 
		for getBean() method to be called.


How to Create a Spring Container?
+	Spring provides many ApplicationContext interface implementations that we use are;		

	+	AnnotationConfigApplicationContext: If we are using Spring in standalone Java applications and using annotations 
			for Configuration, then we can use this to initialize the container and get the bean objects.

	+	ClassPathXmlApplicationContext: If we have spring bean configuration XML file in a standalone application, then we 
			can use this class to load the file and get the container object. XML file should be available in the
			class path.

	+	FileSystemXmlApplicationContext: This is similar to ClassPathXmlApplicationContext except that the XML configuration 
			file can be loaded from anywhere in the file system.


Difference Between BeanFactory vs ApplicationContext in Spring?
+	The BeanFactory interface
	+	use lazy loading, which means that Beans are only instantiating when we directly calling them through the getBean() method.
	+	The most used implementation of the BeanFactory interface is the XmlBeanFactory class.  

		eg:
			XmlBeanFactory factory = new XmlBeanFactory (new ClassPathResource("applicationContext.xml"));


+	The ApplicationContext interface

	+	The ApplicationContext is the central interface within a Spring application for providing configuration information 
		to the application.
	+	It implements the BeanFactory interface. Hence ApplicationContext includes all functionality of the BeanFactory and 
		much more!

	Features:
	+	Bean instantiation/wiring
	+	Automatic BeanPostProcessor registration
	+	Automatic BeanFactoryPostProcessor registration
	+	Convenient MessageSource access (for i18n)
	+	ApplicationEvent publication
	+	Uses eager loading, so every bean instantiate after the ApplicationContext started up.




Spring Dependency Injection 

+	Dependency injection (DI) is a process whereby objects define their dependencies, that is, the other objects they work with, 
	only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is 
	constructed or returned from a factory method. 
+	The container then injects those dependencies when it creates the bean. 

+	This process is fundamentally the inverse, hence the name Inversion of Control (IoC), of the bean itself controlling the 
	instantiation or location of its dependencies on its own by using direct construction of classes, or the Service Locator pattern.

+	The Spring Framework Inversion of Control (IoC) component is the nucleus of the framework. It uses dependency injection to 
	assemble Spring-provided (also called infrastructure components) and development-provided components in order to rapidly wrap 
	up an application.

Advantages of Dependency Injection
+	Decoupling: Code is cleaner with the DI principle and decoupling is more effective when objects are provided with 
	their dependencies.
+	Easier to test: As such, your classes become easier to test, in particular when the dependencies are on interfaces or
	abstract base classes, which allow for stub or mock implementations to be used in unit tests.

Types of Dependency Injection
+	Constructor-based dependency injection
+	Setter-based dependency injection.




1) single ton
2) dao
3) factory design pattern
4) service locator (program-to-interfaces)



annotations:
---------------
stereo type annotations:
	@Component
	+	@Service
	+	@Repository
	+	@Controller
	+	@Configuration

Auto wiring	:	to inject other beans (dependency injection)
	i) by name	(it uses bean name or object name to detect the dependent bean - @Qualifier)
	ii) by type	(it uses class name to detect the dependent bean
	iii) constructor


Spring Bean Scopes:
+	singleton	(default)
+	prototype

+	request
+	session
+	application


Spring Bean Life Cycle Methods:
+	init
+	destroy

if you use annotation based configuration, we can use @PostConstruct, @PreDestroy must be used 
if you use xml based configuration, we have to use init-method = "init()", destroy-method="destroy()" in the <bean> tag.



								Spring AOP 
								----------

AOP is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. 
It does so by adding additional behavior to existing code without modification of the code itself. Instead, we declare 
separately which code is to modify.

What is a cross-cutting concern?
+	A cross-cutting concern is a functionality that is tangled with business code, which usually cannot be separated from 
	the business logic. 
+	Auditing, security, and transaction management are good examples of cross-cutting concerns. 
+	They are mingled with the business code, heavily coupled with the functionality that might be affected if they fail. 
+	you can imagine aspects as plugins. They modify the behaviour, not the actual implementation.

Below diagram shows how the concerns like logging, security, and transaction management are cutting across different layers here:

(diagram)

Examples of cross-cutting concerns:
+	Logging
+	Security
+	Transaction management
+	Auditing,
+	Caching
+	Internationalization
+	Error detection and correction
+	Memory management
+	Performance monitoring


AspectJ:
--------
+	AspectJ is an original library that provided components for creating aspects is named AspectJ. 
+	It was developed by the Xerox PARC company and released in 1995. 
+	It defined a standard for AOP because of its simplicity and usability.



Spring - Spring Core, Spring MVC, Spring Boot, Spring REST, Spring Boot


final project-2



Aspect Oriented Programming

    An aspect is a domain independent cross cutting concern or operation
    that can used across our application.

        Like 
                logging
                transaction management
                security (authentication and authorization) ...etc

    we can configuarwe the aspects to execute after or before or around a regular bussienss logic
    by still keeping them isolated.


    the cross-cutting concern tobe executed is called ASPECT
    and the actual bussiness logic by reference to whcihan aspect has to exeucte is calle JOIN POINT
    to let the ASPECT know the JOIN POIINt, the POINT CUT is used.

    PointCut
    ------------------------
    "execution(* packageName.ClassName.methodName(..))"
    
    AspectJ Annotations
    -------------------------
    @EnableAspectJAutoProxy
    @Aspect - Represents an aspect advice class.
    @Before – Run before the method execution
    @After – Run after the method returned a result
    @AfterReturning – Run after the method returned a result, intercept the returned result as well.
    @AfterThrowing – Run after the method throws an exception
    @Around – Run around the method execution, combine all three advices above.
    
    
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aop</artifactId>
        <version>${spring.version}</version>
    </dependency>

    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjrt</artifactId>


        <version>1.6.11</version>
    </dependency>
    
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjweaver</artifactId>
        <version>1.6.11</version>
    </dependency>






